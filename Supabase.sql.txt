-- MTB Points — Supabase SQL (v1 corrigé)
-- Objectifs:
-- - meetings.id TEXT (compat ids front)
-- - races.id TEXT ; races.meeting_id TEXT NOT NULL (pas d’épreuve hors événement)
-- - delete cascade meeting -> races -> results
-- - profiles.id UUID = auth.users.id + role rider/organizer/admin
-- - RLS: public read sur données "publiques", write organizer/admin
-- - Vues publiques: v_public_races, v_public_results

create extension if not exists "pgcrypto";

-- ------------------------------------------------------------
-- 1) PROFILES
-- ------------------------------------------------------------
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text,
  display_name text,
  role text not null default 'rider' check (role in ('rider','organizer','admin')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists profiles_role_idx on public.profiles(role);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

-- Trigger: créer un profile automatiquement à l’inscription
-- rôle lu depuis raw_user_meta_data.role si présent, sinon rider
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  r text;
begin
  r := coalesce(nullif(new.raw_user_meta_data->>'role',''), 'rider');

  -- harden
  if r not in ('rider','organizer','admin') then
    r := 'rider';
  end if;

  insert into public.profiles (id, email, display_name, role)
  values (
    new.id,
    new.email,
    coalesce(nullif(new.raw_user_meta_data->>'display_name',''), split_part(new.email,'@',1)),
    r
  )
  on conflict (id) do update
    set email = excluded.email;

  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- Helpers rôle (lisent profiles)
create or replace function public.is_admin()
returns boolean
language sql
stable
as $$
  select exists (
    select 1 from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  );
$$;

create or replace function public.is_organizer_or_admin()
returns boolean
language sql
stable
as $$
  select exists (
    select 1 from public.profiles p
    where p.id = auth.uid()
      and p.role in ('organizer','admin')
  );
$$;

-- RLS profiles
alter table public.profiles enable row level security;

drop policy if exists "profiles_select_own" on public.profiles;
create policy "profiles_select_own"
on public.profiles
for select
to authenticated
using (id = auth.uid() or public.is_admin());

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles
for update
to authenticated
using (id = auth.uid() or public.is_admin())
with check (id = auth.uid() or public.is_admin());

-- (optionnel) interdire insert manuel (géré par trigger)
drop policy if exists "profiles_no_manual_insert" on public.profiles;
create policy "profiles_no_manual_insert"
on public.profiles
for insert
to authenticated
with check (false);


-- ------------------------------------------------------------
-- 2) MEETINGS (événements)
-- ------------------------------------------------------------
create table if not exists public.meetings (
  id text primary key,
  owner_id uuid not null references auth.users(id) on delete restrict,
  name text not null,
  date date not null,          -- date début
  end_date date,               -- date fin (optionnel)
  location text,
  comment text,
  is_public boolean not null default true,

  -- compat front: liste des ids d’épreuves rattachées
  race_ids text[] not null default '{}',

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint meetings_end_date_check
    check (end_date is null or end_date >= date)
);

create index if not exists meetings_owner_idx on public.meetings(owner_id);
create index if not exists meetings_public_idx on public.meetings(is_public);
create index if not exists meetings_date_idx on public.meetings(date);

drop trigger if exists trg_meetings_updated_at on public.meetings;
create trigger trg_meetings_updated_at
before update on public.meetings
for each row execute function public.set_updated_at();

alter table public.meetings enable row level security;

-- Lecture publique: uniquement événements publics
drop policy if exists "meetings_public_read" on public.meetings;
create policy "meetings_public_read"
on public.meetings
for select
to anon, authenticated
using (is_public = true);

-- Organizers/admin: CRUD sur leurs événements (admin: tous)
drop policy if exists "meetings_org_insert" on public.meetings;
create policy "meetings_org_insert"
on public.meetings
for insert
to authenticated
with check (
  public.is_organizer_or_admin()
  and owner_id = auth.uid()
);

drop policy if exists "meetings_org_update" on public.meetings;
create policy "meetings_org_update"
on public.meetings
for update
to authenticated
using (
  public.is_admin()
  or (public.is_organizer_or_admin() and owner_id = auth.uid())
)
with check (
  public.is_admin()
  or (public.is_organizer_or_admin() and owner_id = auth.uid())
);

drop policy if exists "meetings_org_delete" on public.meetings;
create policy "meetings_org_delete"
on public.meetings
for delete
to authenticated
using (
  public.is_admin()
  or (public.is_organizer_or_admin() and owner_id = auth.uid())
);


-- ------------------------------------------------------------
-- 3) RACES (épreuves) — OBLIGATOIREMENT rattachées à un meeting
-- ------------------------------------------------------------
create table if not exists public.races (
  id text primary key,
  meeting_id text not null references public.meetings(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete restrict,

  name text not null,
  date date not null,
  time time,

  disc text,
  ebike boolean not null default false,

  distance_km numeric,
  dplus_m integer,
  participants integer,
  comment text,

  -- Scores (optionnels)
  phys_score integer,
  global_score integer,
  tech_v2 jsonb,

  gpx_file_name text,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  constraint races_score_range check (
    (phys_score is null or (phys_score between 0 and 100))
    and (global_score is null or (global_score between 0 and 100))
  )
);

create index if not exists races_meeting_idx on public.races(meeting_id);
create index if not exists races_owner_idx on public.races(owner_id);
create index if not exists races_date_idx on public.races(date);
create index if not exists races_disc_idx on public.races(disc);

drop trigger if exists trg_races_updated_at on public.races;
create trigger trg_races_updated_at
before update on public.races
for each row execute function public.set_updated_at();

alter table public.races enable row level security;

-- Lecture publique: races dont le meeting est public
drop policy if exists "races_public_read" on public.races;
create policy "races_public_read"
on public.races
for select
to anon, authenticated
using (
  exists (
    select 1 from public.meetings m
    where m.id = races.meeting_id
      and m.is_public = true
  )
);

-- Insert/update/delete: organizer/admin, et owner_id = auth.uid()
drop policy if exists "races_org_insert" on public.races;
create policy "races_org_insert"
on public.races
for insert
to authenticated
with check (
  public.is_organizer_or_admin()
  and owner_id = auth.uid()
  and exists (
    select 1 from public.meetings m
    where m.id = meeting_id
      and (public.is_admin() or m.owner_id = auth.uid())
  )
);

drop policy if exists "races_org_update" on public.races;
create policy "races_org_update"
on public.races
for update
to authenticated
using (
  public.is_admin()
  or (public.is_organizer_or_admin() and owner_id = auth.uid())
)
with check (
  public.is_admin()
  or (public.is_organizer_or_admin() and owner_id = auth.uid())
);

drop policy if exists "races_org_delete" on public.races;
create policy "races_org_delete"
on public.races
for delete
to authenticated
using (
  public.is_admin()
  or (public.is_organizer_or_admin() and owner_id = auth.uid())
);


-- ------------------------------------------------------------
-- 4) RESULTS
-- ------------------------------------------------------------
create table if not exists public.results (
  id uuid primary key default gen_random_uuid(),
  race_id text not null references public.races(id) on delete cascade,

  rider_id uuid references public.profiles(id) on delete set null,

  bib text,
  first_name text,
  last_name text,
  sex text check (sex in ('M','F')),

  category text,
  age integer,
  nationality text,

  time_seconds integer,
  rank integer,

  points numeric,

  created_at timestamptz not null default now()
);

create index if not exists results_race_idx on public.results(race_id);
create index if not exists results_rider_idx on public.results(rider_id);

alter table public.results enable row level security;

-- Lecture publique: résultats dont le meeting est public
drop policy if exists "results_public_read" on public.results;
create policy "results_public_read"
on public.results
for select
to anon, authenticated
using (
  exists (
    select 1
    from public.races r
    join public.meetings m on m.id = r.meeting_id
    where r.id = results.race_id
      and m.is_public = true
  )
);

-- Insert/update/delete: organizer/admin uniquement
drop policy if exists "results_org_insert" on public.results;
create policy "results_org_insert"
on public.results
for insert
to authenticated
with check (
  public.is_organizer_or_admin()
  and exists (
    select 1
    from public.races r
    join public.meetings m on m.id = r.meeting_id
    where r.id = race_id
      and (public.is_admin() or m.owner_id = auth.uid())
  )
);

drop policy if exists "results_org_update" on public.results;
create policy "results_org_update"
on public.results
for update
to authenticated
using (
  public.is_admin()
  or (
    public.is_organizer_or_admin()
    and exists (
      select 1
      from public.races r
      join public.meetings m on m.id = r.meeting_id
      where r.id = results.race_id
        and m.owner_id = auth.uid()
    )
  )
)
with check (true);

drop policy if exists "results_org_delete" on public.results;
create policy "results_org_delete"
on public.results
for delete
to authenticated
using (
  public.is_admin()
  or (
    public.is_organizer_or_admin()
    and exists (
      select 1
      from public.races r
      join public.meetings m on m.id = r.meeting_id
      where r.id = results.race_id
        and m.owner_id = auth.uid()
    )
  )
);


-- ------------------------------------------------------------
-- 5) VUES PUBLIQUES
-- ------------------------------------------------------------
create or replace view public.v_public_races as
select
  r.*,
  m.name as meeting_name,
  m.date as meeting_start_date,
  m.end_date as meeting_end_date,
  m.location as meeting_location,
  m.is_public as meeting_is_public
from public.races r
join public.meetings m on m.id = r.meeting_id
where m.is_public = true;

create or replace view public.v_public_results as
select
  res.*,
  r.name as race_name,
  r.date as race_date,
  r.disc as race_disc,
  r.ebike as race_ebike,
  r.meeting_id,
  m.name as meeting_name,
  m.date as meeting_start_date,
  m.location as meeting_location
from public.results res
join public.races r on r.id = res.race_id
join public.meetings m on m.id = r.meeting_id
where m.is_public = true;

-- Rendre les vues lisibles en public (avec RLS en amont sur tables, OK)
grant select on public.v_public_races to anon, authenticated;
grant select on public.v_public_results to anon, authenticated;

